üìå Estrutura do C√≥digo
VaultAuthenticator.cs ‚Üí Gerencia a autentica√ß√£o no HashiCorp Vault e a obten√ß√£o do JWT.
MicrosoftGraphClient.cs ‚Üí Gerencia a valida√ß√£o do JWT e a leitura de e-mails no Microsoft Graph.
Program.cs ‚Üí Apenas chama os m√©todos.
üìå VaultAuthenticator.cs (Autentica√ß√£o no Vault e Obten√ß√£o do JWT)

using System;
using System.Net.Http;
using System.Security.Cryptography.X509Certificates;
using System.Text.Json;
using System.Threading.Tasks;

public class VaultAuthenticator
{
    private readonly string _certPath;
    private readonly string _keyPath;
    private readonly string _caPath;
    private readonly string _vaultUrl = "https://seu-vault-url.com/v1/auth/cert/login";
    private readonly string _tenantId = "SEU_TENANT_ID";
    private readonly string _clientId = "SEU_CLIENT_ID";

    public VaultAuthenticator()
    {
        // Define os caminhos dos certificados na pasta Certificados do projeto
        string basePath = AppDomain.CurrentDomain.BaseDirectory + "Certificados/";
        _certPath = basePath + "certificado.pem";
        _keyPath = basePath + "chave.pem";
        _caPath = basePath + "CA.pem";
    }

    /// <summary>
    /// Executa o fluxo completo: valida certificados, autentica no Vault, obt√©m o Client Secret e retorna um JWT v√°lido.
    /// </summary>
    public async Task<string> AuthenticateAndGetJwtAsync()
    {
        if (!ValidateCertificates())
        {
            throw new Exception("Certificados inv√°lidos.");
        }

        HttpClient httpClient = CreateHttpClient();
        string hvsToken = await AuthenticateVault(httpClient);
        string clientSecret = await GetClientSecretFromVault(httpClient, hvsToken);
        return await GetMicrosoftGraphJwt(clientSecret);
    }

    /// <summary>
    /// Valida se os certificados est√£o corretos e carreg√°veis.
    /// </summary>
    private bool ValidateCertificates()
    {
        try
        {
            _ = new X509Certificate2(_caPath);
            _ = new X509Certificate2(_certPath);
            return true;
        }
        catch
        {
            return false;
        }
    }

    /// <summary>
    /// Cria um HttpClient configurado com autentica√ß√£o mTLS.
    /// </summary>
    private HttpClient CreateHttpClient()
    {
        var handler = new HttpClientHandler();
        var caCert = new X509Certificate2(_caPath);

        handler.ServerCertificateCustomValidationCallback = (message, cert, chain, errors) =>
        {
            return chain.ChainElements[0].Certificate.Thumbprint == caCert.Thumbprint;
        };

        var clientCert = new X509Certificate2(_certPath);
        handler.ClientCertificates.Add(clientCert);

        return new HttpClient(handler);
    }

    /// <summary>
    /// Autentica no HashiCorp Vault e retorna um token HVS.
    /// </summary>
    private async Task<string> AuthenticateVault(HttpClient httpClient)
    {
        var response = await httpClient.PostAsync(_vaultUrl, null);
        response.EnsureSuccessStatusCode();
        var responseJson = await response.Content.ReadAsStringAsync();
        var json = JsonSerializer.Deserialize<JsonElement>(responseJson);
        return json.GetProperty("auth").GetProperty("client_token").GetString();
    }

    /// <summary>
    /// Obt√©m o Client Secret armazenado no Vault usando o token HVS.
    /// </summary>
    private async Task<string> GetClientSecretFromVault(HttpClient httpClient, string hvsToken)
    {
        string vaultSecretUrl = "https://seu-vault-url.com/v1/secret/data/microsoft-client-secret";
        var request = new HttpRequestMessage(HttpMethod.Get, vaultSecretUrl);
        request.Headers.Add("X-Vault-Token", hvsToken);
        var response = await httpClient.SendAsync(request);
        response.EnsureSuccessStatusCode();
        var responseJson = await response.Content.ReadAsStringAsync();
        var json = JsonSerializer.Deserialize<JsonElement>(responseJson);
        return json.GetProperty("data").GetProperty("data").GetProperty("client_secret").GetString();
    }

    /// <summary>
    /// Obt√©m um JWT Bearer do Microsoft Graph API usando o Client Secret.
    /// </summary>
    private async Task<string> GetMicrosoftGraphJwt(string clientSecret)
    {
        string tokenUrl = $"https://login.microsoftonline.com/{_tenantId}/oauth2/v2.0/token";
        var httpClient = new HttpClient();
        var content = new FormUrlEncodedContent(new[]
        {
            new KeyValuePair<string, string>("client_id", _clientId),
            new KeyValuePair<string, string>("client_secret", clientSecret),
            new KeyValuePair<string, string>("scope", "https://graph.microsoft.com/.default"),
            new KeyValuePair<string, string>("grant_type", "client_credentials")
        });

        var response = await httpClient.PostAsync(tokenUrl, content);
        response.EnsureSuccessStatusCode();
        var responseJson = await response.Content.ReadAsStringAsync();
        var json = JsonSerializer.Deserialize<JsonElement>(responseJson);
        return json.GetProperty("access_token").GetString();
    }
}
üìå MicrosoftGraphClient.cs (Valida√ß√£o do JWT e Leitura de E-mails)

using System;
using System.IdentityModel.Tokens.Jwt;
using System.Net.Http;
using System.Security.Claims;
using System.Text.Json;
using System.Threading.Tasks;
using Microsoft.IdentityModel.Tokens;

public class MicrosoftGraphClient
{
    private readonly string _tenantId = "SEU_TENANT_ID";
    private readonly string _userEmail = "email@dominio.com"; // Defina o e-mail do usu√°rio aqui

    /// <summary>
    /// Valida se um JWT √© v√°lido e confi√°vel.
    /// </summary>
    public bool ValidateJwt(string token, out ClaimsPrincipal principal)
    {
        principal = null;

        try
        {
            var tokenHandler = new JwtSecurityTokenHandler();
            var validationParameters = new TokenValidationParameters
            {
                ValidateIssuerSigningKey = false,
                ValidateIssuer = true,
                ValidIssuer = $"https://login.microsoftonline.com/{_tenantId}/v2.0",
                ValidateAudience = true,
                ValidAudience = "https://graph.microsoft.com",
                ValidateLifetime = true,
                ClockSkew = TimeSpan.Zero
            };

            principal = tokenHandler.ValidateToken(token, validationParameters, out SecurityToken validatedToken);
            return true;
        }
        catch
        {
            return false;
        }
    }

    /// <summary>
    /// Verifica se o JWT cont√©m as permiss√µes necess√°rias (Mail.Read ou Mail.Send).
    /// </summary>
    public bool HasRequiredPermissions(ClaimsPrincipal principal)
    {
        var scopes = principal.FindFirst("scp")?.Value ?? "";
        var roles = principal.FindFirst("roles")?.Value ?? "";

        return scopes.Contains("Mail.Read") || scopes.Contains("Mail.Send") ||
               roles.Contains("Mail.Read") || roles.Contains("Mail.Send");
    }

    /// <summary>
    /// Obt√©m e-mails do Microsoft Graph API usando um JWT Bearer v√°lido.
    /// </summary>
    public async Task GetEmailsFromMicrosoftGraph(string jwtBearer)
    {
        string graphUrl = $"https://graph.microsoft.com/v1.0/users/{_userEmail}/messages";

        using (var httpClient = new HttpClient())
        {
            httpClient.DefaultRequestHeaders.Authorization = new System.Net.Http.Headers.AuthenticationHeaderValue("Bearer", jwtBearer);
            var response = await httpClient.GetAsync(graphUrl);

            if (!response.IsSuccessStatusCode)
            {
                throw new Exception($"Falha ao acessar emails. C√≥digo de erro: {response.StatusCode}");
            }

            string responseJson = await response.Content.ReadAsStringAsync();
            Console.WriteLine(responseJson);
        }
    }
}
üìå Program.cs (Chamada dos M√©todos)

using System;
using System.Threading.Tasks;

class Program
{
    static async Task Main()
    {
        try
        {
            VaultAuthenticator vaultAuth = new VaultAuthenticator();
            string jwtBearer = await vaultAuth.AuthenticateAndGetJwtAsync();

            MicrosoftGraphClient graphClient = new MicrosoftGraphClient();
            if (graphClient.ValidateJwt(jwtBearer, out ClaimsPrincipal principal) && graphClient.HasRequiredPermissions(principal))
            {
                await graphClient.GetEmailsFromMicrosoftGraph(jwtBearer);
            }
            else
            {
                Console.WriteLine("JWT inv√°lido ou sem permiss√µes suficientes.");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Erro: {ex.Message}");
        }
    }
}
Agora o c√≥digo est√° bem documentado e organizado. Se precisar de ajustes, me avise!
