O erro AuthenticationException: The remote certificate was rejected by the provided RemoteCertificateValidationCallback indica que o certificado do servidor nÃ£o foi aceito pelo cliente. Isso pode acontecer por alguns motivos:

ğŸ“Œ PossÃ­veis Causas e SoluÃ§Ãµes
1ï¸âƒ£ O CA.pem nÃ£o corresponde ao certificado do servidor
ğŸ”¹ SoluÃ§Ã£o: Verifique se o CA.pem realmente Ã© a autoridade certificadora do certificado do servidor.
ğŸ”¹ Para testar manualmente:

sh
Copiar
Editar
openssl s_client -connect seu-vault-url.com:443 -CAfile CA.pem
Se o certificado nÃ£o for confiÃ¡vel, ele nÃ£o serÃ¡ aceito.

2ï¸âƒ£ O callback de validaÃ§Ã£o SSL estÃ¡ rejeitando o certificado
ğŸ”¹ SoluÃ§Ã£o: Modifique o callback para permitir qualquer certificado temporariamente e verifique se isso resolve:

csharp
Copiar
Editar
handler.ServerCertificateCustomValidationCallback = (message, cert, chain, errors) => true;
âš  AtenÃ§Ã£o: Isso desativa a validaÃ§Ã£o SSL, use apenas para testar!

3ï¸âƒ£ O CA.pem nÃ£o estÃ¡ sendo carregado corretamente
ğŸ”¹ SoluÃ§Ã£o: Verifique se o CA.pem estÃ¡ correto e vÃ¡lido:

csharp
Copiar
Editar
var caCert = new X509Certificate2("Certificados/CA.pem");
Console.WriteLine("CA carregado: " + caCert.Subject);
Se lanÃ§ar uma exceÃ§Ã£o, o arquivo pode estar corrompido.

4ï¸âƒ£ O servidor estÃ¡ usando um certificado autoassinado
ğŸ”¹ SoluÃ§Ã£o: Se for um ambiente interno, vocÃª pode precisar adicionar o CA Ã  loja de certificados confiÃ¡veis do Windows/Linux.

ğŸ“Œ Como Corrigir no CÃ³digo
Aqui estÃ¡ um cÃ³digo atualizado para lidar melhor com a validaÃ§Ã£o SSL:

ğŸ”¹ Atualize o CreateHttpClient()
csharp
Copiar
Editar
private HttpClient CreateHttpClient()
{
    var handler = new HttpClientHandler();
    
    // Carregar o certificado PFX
    var clientCert = new X509Certificate2(_pfxPath, _pfxPassword);
    handler.ClientCertificates.Add(clientCert);

    // Carregar o CA.pem para validar conexÃµes SSL
    var caCert = new X509Certificate2(_caPath);

    // Definir a validaÃ§Ã£o de certificado
    handler.ServerCertificateCustomValidationCallback = (httpRequestMessage, cert, chain, sslPolicyErrors) =>
    {
        if (sslPolicyErrors == System.Net.Security.SslPolicyErrors.None)
            return true; // O certificado Ã© vÃ¡lido

        Console.WriteLine($"âš  Certificado rejeitado: {cert.Subject}");
        
        // Verifica se o certificado recebido corresponde ao CA esperado
        return chain.ChainElements[0].Certificate.Thumbprint == caCert.Thumbprint;
    };

    return new HttpClient(handler);
}
ğŸ“Œ Resumo
âœ” Verifique se o CA.pem Ã© vÃ¡lido e corresponde ao servidor
âœ” Se necessÃ¡rio, teste permitindo qualquer certificado (return true;)
âœ” Confirme que o CA.pem estÃ¡ sendo carregado corretamente no cÃ³digo
âœ” Se for um certificado autoassinado, adicione o CA ao sistema operacional

Testa essas soluÃ§Ãµes e me avise se o erro persistir! ğŸš€
